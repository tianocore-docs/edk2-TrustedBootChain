
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>TCG Trusted Boot Chain in EDK II Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="4_Other_Trusted_Boot_Chains.html" />
    
    
    <link rel="prev" href="2_Overview.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Understanding the Trusted Boot Chain Implementation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="TABLES.html">
            
                <a href="TABLES.html">
            
                    
                    Tables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="FIGURES.html">
            
                <a href="FIGURES.html">
            
                    
                    Figures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="1_Executive_Summary.html">
            
                <a href="1_Executive_Summary.html">
            
                    
                    Executive Summary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="2_Overview.html">
            
                <a href="2_Overview.html">
            
                    
                    Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.6" data-path="3_TCG_Trusted_Boot_Chain_in_EDKII.html">
            
                <a href="3_TCG_Trusted_Boot_Chain_in_EDKII.html">
            
                    
                    TCG Trusted Boot Chain in EDK II
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="4_Other_Trusted_Boot_Chains.html">
            
                <a href="4_Other_Trusted_Boot_Chains.html">
            
                    
                    Other Trusted Boot Chains
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="5_Looking_Forward.html">
            
                <a href="5_Looking_Forward.html">
            
                    
                    Looking Forward
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="6_Checklist_for_Platform_Developers.html">
            
                <a href="6_Checklist_for_Platform_Developers.html">
            
                    
                    Checklist for Platform Developers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="7_Glossary.html">
            
                <a href="7_Glossary.html">
            
                    
                    Glossary
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="8_References.html">
            
                <a href="8_References.html">
            
                    
                    References
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >TCG Trusted Boot Chain in EDK II</a>
    </h1>
</div>
<div>
    <!-- 
    <img style="float:left; align:middle; height:2em" src="media/TianocoreTitlePageLogo.jpg"/>
     -->
    
      <h2>
        <div style="position:absolute;text-align:left">Understanding the Trusted Boot Chain Implementation</div>
        <div style="position:absolute;width:100%;text-align:center">DRAFT [03/30/2021 03:24:01]</div>
        <div style="text-align:right">Revision 1.0</div>
      </h2>  
    
    <hr>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <!--- @file
  Understanding the Trusted Boot Chain Implementation

  Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>

  Redistribution and use in source (original document form) and 'compiled'
  forms (converted to PDF, epub, HTML and other formats) with or without
  modification, are permitted provided that the following conditions are met:

  1) Redistributions of source code (original document form) must retain the
     above copyright notice, this list of conditions and the following
     disclaimer as the first lines of this file unmodified.

  2) Redistributions in compiled form (transformed to other DTDs, converted to
     PDF, epub, HTML and other formats) must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

  THIS DOCUMENTATION IS PROVIDED BY TIANOCORE PROJECT "AS IS" AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
  EVENT SHALL TIANOCORE PROJECT  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-->
<h1 id="tcg-trusted-boot-chain-in-edk-ii">TCG Trusted Boot Chain in EDK II</h1>
<h2 id="trusted-boot-flow">Trusted Boot Flow</h2>
<p>Trusted boot flow is activity that the host platform firmware measures,
including firmware components, into the Trusted Platform Module (TPM)
Platform Configuration Register (PCR), and records the actions in an
event log. The TPM acts as a static Root of Trust for Storage (RTS) and
Root of Trust for Reporting (RTR). The platform firmware here acts as a
Static Root of Trust for Measurement (SRTM).</p>
<p>In this document, we use TPM 2.0 as an example. Unless otherwise
specified, the term TPM below refers to a TPM 2.0 device.</p>
<h2 id="pcr-measurement-and-attestation">PCR, Measurement, and Attestation</h2>
<p>The TPM PCRs hold the values of the data measurement. The measurement
follows the equation below. This operation is PCR extend.</p>
<p><strong>PCR <sub>(new)</sub> = HASH (PCR <sub>(old)</sub> || HASH(Data))</strong></p>
<p>PCR extend is the only way to modify the PCR value. If a platform
extends a PCR multiple times, all data is hashed into the PCR. The
vertical bars in parentheses designate the catenation of the old and new
data, respectively.</p>
<h3 id="general-guideline">General Guideline</h3>
<p>A typical TPM has 24 PCRs. PCRs [0-15] represent the SRTM and are
associated with Locality 0. PCRs [0-7] are used for platform firmware
and PCRs [8-15] are used for the operating system. PCR [16] is for
debug usage. PCR [23] is for application support. PCRs [17-22]
represent the platform&apos;s dynamic root of trust for measurement (DRTM).
In this document we will focus on the usage of PCRs [0-7], as
described in the following table.</p>
<h6 id="table-1-tpm-pcr-usage">Table 1 TPM PCR Usage</h6>
<table>
<thead>
<tr>
<th><strong>PCR Index</strong></th>
<th><strong>PCR Usage</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>SRTM, BIOS, Host Platform Extensions, Embedded Option ROMs and PI Drivers</td>
</tr>
<tr>
<td>1</td>
<td>Host Platform Configuration</td>
</tr>
<tr>
<td>2</td>
<td>UEFI driver and application Code</td>
</tr>
<tr>
<td>3</td>
<td>UEFI driver and application Configuration and Data</td>
</tr>
<tr>
<td>4</td>
<td>UEFI Boot Manager Code (usually the MBR) and Boot Attempts</td>
</tr>
<tr>
<td>5</td>
<td>Boot Manager Code Configuration and Data (for use by the Boot Manager Code) and GPT/Partition Table</td>
</tr>
<tr>
<td>6</td>
<td>Host Platform Manufacturer Specific</td>
</tr>
<tr>
<td>7</td>
<td>Secure Boot Policy, Secure boot Verification Authority</td>
</tr>
</tbody>
</table>
<p>(Source: <a href="https://trustedcomputinggroup.org/resource/pc-client-specific-platform-firmware-profile-specification/" target="_blank">TCG PFP Specification</a>)</p>
<p>The following figure shows the high-level components and measurements.</p>
<h6 id="figure-2-high-level-components-and-measurements">Figure 2 High level components and measurements</h6>
<p><img src="media/image2.png" alt=""></p>
<p>(See Building Secure Firmware by Jiewen Yao &amp; Vincent Zimmer)</p>
<p>There is an easy way to remember Table 1, as described by the following
two rules:</p>
<p>1)  Even-numbered PCRs are for the code, while odd-numbered PCRs are for
    configuration data.</p>
<p>2)  PCRs [0-1] are for the OEM, PCRs [2-3] are for third party
    usage, PCRs [4-5] are for OS boot, PCR[7] is for secure boot
    policy, PCR[6] is undefined by the PFP spec and is
    platform-specific.</p>
<h6 id="table-2-pcr-usage-simple-rules">Table 2 PCR usage (simple rules)</h6>
<table>
<thead>
<tr>
<th>Type</th>
<th>Code</th>
<th>Data Configuration</th>
</tr>
</thead>
<tbody>
<tr>
<td>OEM</td>
<td>PCR[0]</td>
<td>PCR[1]</td>
</tr>
<tr>
<td>Third party</td>
<td>PCR[2]</td>
<td>PCR[3]</td>
</tr>
<tr>
<td>OS Boot</td>
<td>PCR[4]</td>
<td>PCR[5]</td>
</tr>
<tr>
<td>Secure Boot Policy</td>
<td>N/A</td>
<td>PCR[7]</td>
</tr>
</tbody>
</table>
<p>For example:</p>
<ul>
<li><p>Any <strong>PEI, DXE, and SMM code in flash FV</strong> are OEM code. They go
into PCR[0].</p>
</li>
<li><p><strong>ACPI data</strong> from OEM code is important for boot. It goes into
PCR[0].</p>
</li>
<li><p>An <strong>integrated PCI card option ROM</strong> in flash FV is provided by the
OEM. It goes to PCR[0]. An <strong>external PCI card Option ROM</strong> is
third party code. It goes into PCR[2].</p>
</li>
<li><p>If <strong>a non-host component</strong> or <strong>a device firmware can only be
updated by OEM</strong> platform code, it goes into PCR[0]. If <strong>a
non-host component</strong> or <strong>a device firmware can be updated by an
entity other than the OEM</strong> platform code, it goes into PCR[2].</p>
</li>
<li><p>A <strong>CPU Microcode update</strong> can be treated as code or data. It can go
into PCR[0] or PCR[1].</p>
</li>
<li><p><strong>SMBIOS tables</strong> are OEM configuration data. They go into PCR[1].</p>
</li>
<li><p><strong>Setup variable</strong> and <strong>policy configuration</strong> are OEM
configuration data. They go into PCR[1].</p>
</li>
<li><p><strong>UEFI Boot####</strong> and <strong>BootOrder variable</strong> are OEM
configuration data. They go into PCR[1].</p>
</li>
<li><p>If <strong>a non-host component</strong> or <strong>a device firmware configuration can
only be updated by OEM</strong> platform code, it goes into PCR[1]. If
<strong>a non-host component</strong> or <strong>a device firmware configuration can be
updated by an entity other than OEM</strong> platform code, it goes into
PCR[3].</p>
</li>
<li><p>If the action is to <strong>enter an OEM provided setup utility</strong>, it goes
into PCR[1]. If the action is to <strong>enter a third party provided
setup utility</strong>, it goes into PCR[3].</p>
</li>
<li><p><strong>OS Loader</strong> is OS boot related code. It goes into PCR[4].</p>
</li>
<li><p><strong>Boot Attempt action</strong> goes into PCR[4]. The <strong>ExitBootService
action</strong> goes into PCR[5].</p>
</li>
<li><p><strong>Disk geometry, such as a GUID partition table (GPT)</strong>, is OS boot
related configuration. It goes into PCR[5].</p>
</li>
<li><p><strong>UEFI Secure Boot variables</strong>, such as the Platform Key (PK), Key
Exchange Key (KEK), image signature database (db), and image
forbidden signature database (dbx) are all related to secure boot
policy. They go into PCR[7].</p>
</li>
<li><p>If <strong>the security configuration policy</strong> is boot security sensitive,
it goes into PCR[7]. If it is NOT boot security sensitive, it goes
into PCR[1].</p>
</li>
<li><p><strong>Secure feature disabling, such as DMA protection disabling,</strong> is
security sensitive. It goes into PCR[7].</p>
</li>
<li><p><strong>Debug mode information</strong> is security sensitive. It goes into
PCR[7].</p>
</li>
</ul>
<p>Some other rules for the data that shall not be measured into PCR are as
follows:</p>
<p>1)  PCRs can only record statically configured, unchangeable data. A
    <strong>PCR cannot record data that are dynamic and changeable across the
    boot</strong>, such as system clock, fan speed, boot count, system reset
    reason, battery power, a nonce value, a pointer, etc.</p>
<p>For example:</p>
<ul>
<li><p>The firmware must measure the PE COFF image before the relocation
into different memory location.</p>
</li>
<li><p>The firmware must measure the ACPI table from flash prior to any
modification. An ACPI table patch may apply different data settings
based upon policy, such as ACPI version selection for a secondary
system description table (SSDT), or different addresses, such as a
non-volatile storage memory location for a differentiated system
description table (DSDT).</p>
</li>
<li><p>The firmware must measure partial portions of the SMBIOS table
because some SMBIOS tables may contain some automatically updated
information, such as WakeupType, Voltage, ResetCount, or
NominalSpeed.</p>
</li>
</ul>
<p>2)  A PCR can only record the class of information. A <strong>PCR cannot
    record the instance of specific information that may be used to
    unique identify a system</strong>, such as an asset tag, a serial number,
    etc.</p>
<p>For example:</p>
<ul>
<li>The firmware must measure partial portions of the SMBIOS tables
because some SMBIOS table entries may contain the instance specific
unique information, such as SerialNumber, UUID, AssetTag,
PartNumber.</li>
</ul>
<p>3)  <strong>A PCR cannot record any privacy sensitive information</strong>.</p>
<p>All of the above PCR measurements need to be recorded into an event log
which can be used to reproduce the PCR value. Besides that, the event
log may include some NO_ACTION event types. This type means that the
data are not required to be measured into PCR. The event log entry is
intended to provide additional information to the event log consumer.
For example:</p>
<ul>
<li><p><strong>Specification ID event</strong> -- It is to provide information to the
consumer regarding which version of specification is implemented.</p>
</li>
<li><p><strong>Reference Manifest event</strong> -- It is to provide NIST SP800-155
reference integrity manifest information, such as platform
manufacturer ID, reference manifest GUID, etc.</p>
</li>
<li><p><strong>Startup Locality event</strong> -- It is to record the locality from
which the TPM2_Startup command was sent in cases where the Locality
sending the TPM2_Startup command is Locality 3.</p>
</li>
</ul>
<p>Most TCG TPM related code in EDK II is located at
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg" target="_blank">SecurityPkg</a>.
The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
module handles the PEI phase measurement. The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
DXE driver handles the DXE phase measurement. The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpm2MeasureBootLib" target="_blank">DxeTpm2MeasureBootLib</a>
library handles the PE image measurements and GPT measurement. All event
type definition can be found at
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">UefiTcgPlatform.h</a>.
Figure 3 below shows the high level flow of the modules.</p>
<h6 id="figure-3-high-level-module-flow">Figure 3 High Level Module Flow</h6>
<p><img src="media/image3.png" alt=""></p>
<h3 id="pcr-0">PCR 0</h3>
<p>The SRTM&apos;s version identifier is measured by the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>MeasureCRTMVersion</strong>() function. The event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_S_CRTM_VERSION</a>.
EDKII uses
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdFirmwareVersionString</a>
to let a platform pass the SRTM version information. The version string
is encoded as a Unicode string with a NULL terminator.</p>
<p>The platform firmware is measured by the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>MeasureFvImage()</strong> function with firmware volume (FV) granularity. The
event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_PLATFORM_FIRMWARE_BLOB</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_PLATFORM_FIRMWARE_BLOB2</a>,
based upon the
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTcgPfpMeasurementRevision</a>.
The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
module measures the main BIOS at <strong>MeasureMainBios</strong>() and then installs
a callback function <strong>FirmwareVolumeInfoPpiNotifyCallback</strong>() at the
memory present entrypoint <strong>PeimEntryMP</strong>(). Whenever a new FV is
installed, this callback is invoked and the new FV is measured.</p>
<p>To avoid duplicated measurements, the
<strong>FirmwareVolumeInfoPpiNotifyCallback</strong>() will carefully check the new
installed FV to ensure that the same FV will not be measured twice. It
will also ensure that the child FV will not be measured.</p>
<p>The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/FirmwareVolumeInfoMeasurementExcluded.h" target="_blank">EFI_PEI_FIRMWARE_VOLUME_INFO_MEASUREMENT_EXCLUDED_PPI</a>
interface is designed to let a platform report to the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
module that the installed FV is already measured. There is no need to
measure it again. This is usually done by a hardware based static root
of trust for measurement, such as Intel Authenticated Code Module (ACM)
in Intel Boot Guard technology. If the ACM has already measured the
initial FV, such as PEI FV into the TPM PCR, then a BootGuard platform
module can report this information. The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>MeasureFvImage</strong>() service will check this PPI in order to skip the
measurement and event log report.</p>
<p>The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/FirmwareVolumeInfoPrehashedFV.h" target="_blank">EDKII_PEI_FIRMWARE_VOLUME_INFO_PREHASHED_FV_PPI</a>
service is designed to let a platform report the hash of an FV to the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>.
This is also done by a hardware based root of trust module without
measuring the FV. The ACM in Intel Boot Guard may just use this hash to
verify the initial FV, such as PEI FV, but not measure the FV according
to the policy. Then a BootGuard platform module can report this
information. Because the hash value is stored in the Boot Guard boot
policy manifest (BPM) and it is also verified by the ACM, the hash can
be trusted.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>MeasureFvImage</strong>() will check this PPI to skip the hash calculation
and directly measure the hash into PCR and also record the event log.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/FirmwareVolumeInfoStoredHashFv.h" target="_blank">EDKII_PEI_FIRMWARE_VOLUME_INFO_STORED_HASH_FV_PPI</a>
is also designed to let a platform report the hash of an FV, but with a
different purpose. The hash is reported to
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/FvReportPei" target="_blank">FvReportPei</a>
for FV verification, but not to the TcgPei for FV measurement. The
intent is to let
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/FvReportPei/FvReportPei.c" target="_blank">FvReportPei.c</a>
<strong>CheckStoredHashFv()</strong> verify the FV based upon the hash. The hash
value is provisioned by the OEM in the Boot Guard BPM. The ACM will NOT
verify the hash value against the corresponding FV, such as the DXE FV.
Since the hash value storage is signed and verified by the ACM it can be
trusted. Then the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/FvReportPei/FvReportPei.c" target="_blank">FvReportPei.c</a>
<strong>VerifyHashedFv()</strong> can verify the DXE FV based upon the hash
information. Once <strong>VerifyHashedFv()</strong> passes the verification, it can
install
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/FirmwareVolumeInfoPrehashedFV.h" target="_blank">EDKII_PEI_FIRMWARE_VOLUME_INFO_PREHASHED_FV_PPI</a>
to Tcg2Pei.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
is not the only module that measures data in the PEI phase. It also
produces
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/Tcg.h" target="_blank">EDKII_TCG_PPI</a>
<strong>HashLogExtendEvent</strong>() API. As such, other module can also measure the
data in the PEI phase by calling
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Include/Library/TpmMeasurementLib.h" target="_blank">TpmMeasurementLib</a>
<strong>TpmMeasureAndLogData</strong>(). The PEI instance
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/PeiTpmMeasurementLib" target="_blank">PeiTpmMeasurementLib</a>
uses the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/Tcg.h" target="_blank">EDKII_TCG_PPI</a>.
Moreover, the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/TcgEventLogRecordLib.h" target="_blank">TcgEventLogRecordLib</a>
provides more services, such as <strong>MeasureFirmwareBlob</strong>() and
<strong>MeasureHandoffTable</strong>(). The
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/TcgEventLogRecordLib/TcgEventLogRecordLib.c" target="_blank">TcgEventLogRecordLib.c</a>
can choose
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_PLATFORM_FIRMWARE_BLOB</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_PLATFORM_FIRMWARE_BLOB2</a>,
and
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_HANDOFF_TABLES</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_HANDOFF_TABLES2</a>
based upon
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTcgPfpMeasurementRevision</a>.</p>
<p>Some platform firmware uses the Intel Firmware Supported Package (FSP)
binary to initialize the silicon. The FSP contains the firmware code. As
such, the FSP binary shall also be measured. The FSP-T and FSP-M are
measured by
<a href="https://github.com/tianocore/edk2/tree/master/IntelFsp2WrapperPkg/FspmWrapperPeim" target="_blank">FspmWrapperPeim</a>.
The FSP-S is measured by
<a href="https://github.com/tianocore/edk2/tree/master/IntelFsp2WrapperPkg/FspsWrapperPeim" target="_blank">FspsWrapperPeim</a>.
They call
<a href="https://github.com/tianocore/edk2/blob/master/IntelFsp2WrapperPkg/Include/Library/FspMeasurementLib.h" target="_blank">FspMeasurementLib</a>
<strong>MeasureFspFirmwareBlob</strong>() and this function calls
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/TcgEventLogRecordLib.h" target="_blank">TcgEventLogRecordLib</a>
<strong>MeasureFirmwareBlob ()</strong>. One special thing about FSP measurement is
that the FSP binary includes not only code but also configuration. A
platform may want to measure the FSP code to PCR0 and FSP static
configuration to PCR1. In order to support that,
<a href="https://github.com/tianocore/edk2/blob/master/IntelFsp2WrapperPkg/Library/BaseFspMeasurementLib/FspMeasurementLib.c" target="_blank">FspMeasurementLib.c</a>
<strong>MeasureFspFirmwareBlob</strong>() refers the <strong>PcdFspMeasurementConfig</strong> to
determine if it needs separate measurements by using
<strong>MeasureFspFirmwareBlobWithCfg</strong>().</p>
<p>All measured firmware volumes are recorded in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/MeasuredFvHob.h" target="_blank">EFI_MEASURED_FV_HOB</a>
by the Tcg2Pei.c <strong>EndofPeiSignalNotifyCallBack</strong>() service in order to
avoid duplicated measurements. If a firmware volume is NOT reported in
the PEI phase, then it needs to be measured in the DXE phase. Similar to
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>,
the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
produces
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
<strong>HashLogExtendEvent</strong>() API. The DXE instance
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpmMeasurementLib" target="_blank">DxeTpmMeasurementLib</a>
uses the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
to let other modules measure more firmware data.</p>
<p>EDK II assumes that all OEM firmware volumes are reported in the PEI
phase. As such, the firmware volume dispatched in the DXE phase is not
measured at FV granularity, but instead the code is measured at PE image
granularity in
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpm2MeasureBootLib" target="_blank">DxeTpm2MeasureBootLib</a>.
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTpm2MeasureBootLib" target="_blank">DxeTpm2MeasureBootLib</a>
is a hook to the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Security2.h" target="_blank">EFI_SECURITY2_ARCH_PROTOCOL</a>.
It is linked with
<a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/SecurityStubDxe" target="_blank">SecurityStubDxe</a>
and
<a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Library/DxeSecurityManagementLib" target="_blank">DxeSecurityManagementLib</a>.
When the DxeCore dispatches an EFI image, it calls
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Security2.h" target="_blank">EFI_SECURITY2_ARCH_PROTOCOL</a>
<strong>FileAuthentication</strong>(). Then <strong>DxeTpm2MeasureBootHandler</strong>() will be
invoked finally. The general rule is that:</p>
<p>1) If a PE image driver or application is from an unmeasured FV, then
the PE image will be measured. A PE image driver will be measured into
PCR2 and a PE image application will be measured into PCR4.</p>
<p>2) If a PE image driver is from a measured FV, it will NOT be measured.</p>
<p>3) If a PE image application is from a measured FV, it will still be
measured to PCR4.</p>
<p>This logic is in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c" target="_blank">DxeTpm2MeasureBootLib.c</a>
<strong>DxeTpm2MeasureBootHandler</strong>(). We will discuss more about this process
in the PCR2 section and PCR4 section, respectively.</p>
<p>If there is an additional executable binary loaded, this executable
binary shall be measured. For example, the SMM Transfer Monitor (STM)
image is measured in
<a href="https://github.com/tianocore/edk2/blob/master/UefiCpuPkg/Library/SmmCpuFeaturesLib/SmmStm.c" target="_blank">SmmStm.c</a>
<strong>LoadMonitor</strong>() with TXT_EVTYPE_STM_HASH.</p>
<p>ACPI tables should be measured before any data patches are applied. For
example, the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
measures the <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm2Acpi.h" target="_blank">TPM2
ACPI</a>
table in <strong>PublishTpm2</strong>() and <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">TPM
SSDT</a>
ACPI table in <strong>PublishAcpiTable</strong>(), before any data patches, such as
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableRev</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLaml</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLasa</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcgPhysicalPresenceInterfaceVer</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2CurrentIrqNum</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2PossibleIrqNumBuf</a>,
etc.</p>
<p>A platform may include a non-host environment, such as the Intel
Management Engine (ME). The non-host information shall be measured with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_INFO</a>
by a platform specific module. If the non-host platform can only be
updated by Platform Firmware, then the non-host code shall be measured
with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CODE</a>
by a platform specific module.</p>
<p>A platform may report the SRTM contents with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_S_CRTM_CONTENTS</a>.
For example, an Intel BootGuard enabled platform may report
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_S_CRTM_CONTENTS</a>
with the BootGuard ACM, Key Manifest (KM) and Boot Policy Manifest (BPM)
information.</p>
<p>EV_SEPARATOR is used to draw a line between the pre-boot environment
and entering a post-boot environment.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
will use <strong>MeasureSeparatorEvent</strong>() to record
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_SEPARATOR</a>
with 0x00000000 for PCR0~6 in the <strong>OnReadyToBoot</strong>() function upon the
first boot attempt. EV_SEPARATOR for PCR7 is handled earlier in
<strong>MeasureSecureBootPolicy</strong>(). We will discuss this later in the PCR7
section.</p>
<p>If a system starts up with an error status, then an error
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_SEPARATOR</a>
shall be measured.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>PeimEntryMA</strong>() detects the error and uses
<strong>MeasureSeparatorEventWithError</strong>() to record
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_SEPARATOR</a>
with 0x00000001 for PCR0~7. More details of TPM error handling will be
discussed later.</p>
<h3 id="pcr-1">PCR 1</h3>
<p>A platform usually includes multiple CPU Microcode update files and put
them all together into a microcode FV. At runtime, the CPU module will
scan them one by one and only load the one matching the current CPU. A
platform may choose to measure the whole Microcode FV or the
individually-used Microcode, such as the one from
<a href="https://github.com/tianocore/edk2/blob/master/UefiCpuPkg/Include/Guid/MicrocodePatchHob.h" target="_blank">EDKII_MICROCODE_PATCH_HOB</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/UefiCpuPkg/UefiCpuPkg.dec" target="_blank">PcdCpuMicrocodePatchAddress</a>.
The current EDK II does not provide an example in the CPU module. A
platform needs to perform such measurement based upon the platform
policy.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/SmbiosMeasurementDxe" target="_blank">SmbiosMeasurementDxe</a>
is an example of SMBIOS table measurement. We call it an example because
the SMBIOS table measurement requires a platform specific policy to skip
the dynamic changeable information and instance-specific unique
information in the table or a field of the table. This
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/SmbiosMeasurementDxe/SmbiosMeasurementDxe.c" target="_blank">SmbiosMeasurementDxe.c</a>
<strong>FilterSmbiosEntry</strong>() will skip all OEM type SMBIOS tables and zero
the dynamic changeable information and instance specific unique
information before the measurement. The policy -
<strong>mSmbiosFilterStandardTableBlackList</strong> is hardcoded in the module. Once
the SMBIOS is filtered, the <strong>MeasureSmbiosTable</strong>() function will
choose the event type
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_HANDOFF_TABLES</a>
or
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_HANDOFF_TABLES2</a>
based upon the
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTcgPfpMeasurementRevision</a>
to measure the SMBIOS table. If a platform wants to use a different
policy, it may implement another SmbiosMeasurementDxe module and not use
this one.</p>
<p>The UEFI boot related variables, such as &quot;Boot####&quot; and &quot;BootOrder.&quot;
are measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>ReadAndMeasureBootVariable</strong>(). The event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_VARIABLE_BOOT</a>.
These variables are measured if they are present in
<strong>MeasureAllBootVariables</strong>().</p>
<p>Other Setup variables or policy configurations are OEM specific data.
They should be measured in an OEM specific module.</p>
<p>For a server platform where
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTpmPlatformClass</a>
is TCG_PLATFORM_TYPE_SERVER, the multi-processor information
(<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/MpService.h" target="_blank">EFI_CPU_PHYSICAL_LOCATION</a>)
is measured by the module
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>MeasureHandoffTables</strong>(). The event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_TABLE_OF_DEVICES</a>.
Other devices are not handled in Tcg2Dxe but may be handled in an OEM
platform module.</p>
<p>If a platform has a setup utility which does not require an
unconditional reset, then the platform shall measure &quot;Entering ROM Based
Setup&quot; with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_ACTION</a>.
This can be done in the platform utility.</p>
<p>A platform may include a non-host environment, such as the Intel
Management Engine (ME). If the non-host platform can only be updated by
the Platform Firmware, then the non-host configuration should be
measured with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CONFIG</a>
by a platform specific module.</p>
<h3 id="pcr-2">PCR 2</h3>
<p>A third party UEFI driver, such as a PCI EFI option ROM, is measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c" target="_blank">DxeTpm2MeasureBootLib.c</a>
<strong>Tcg2MeasurePeImage</strong>() in <strong>DxeTpm2MeasureBootHandler</strong>(). The event
type for a UEFI boot services driver is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_BOOT_SERVICES_DRIVER</a>
and the event type for a UEFI runtime services driver is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_RUNTIME_SERVICES_DRIVER</a>.
If a UEFI driver resides in an unmeasured FV which is dispatched in the
DXE phase, it is also measured with the same policy into PCR2.</p>
<p>A platform may include a non-host environment, such as Intel Management
Engine (ME). If the non-host platform can be updated by entities other
than the Platform Firmware, then the non-host code shall be measured
with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CODE</a>
by a platform specific module.</p>
<p>A platform may include Secure Protocol and Data Model
(<a href="https://www.dmtf.org/sites/default/files/standards/documents/DSP0274_1.1.0.pdf" target="_blank">SPDM</a>)
capable devices. The platform should use the GET_MEASUREMENT command to
retrieve the device firmware measurement and measure the immutable ROM
and mutable firmware with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_SPDM_FIRMWARE_BLOB</a>
in
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_DEVICE_SECURITY_EVENT_DATA</a>.
A prototype can be found at
<a href="https://github.com/jyao1/edk2/tree/DeviceSecurity/DeviceSecurityPkg" target="_blank">DeviceSecurityPkg</a>
<a href="https://github.com/jyao1/edk2/blob/DeviceSecurity/DeviceSecurityPkg/SpdmDeviceSecurityDxe/SpdmDeviceMeasurement.c" target="_blank">SpdmDeviceMeasurement.c</a>.
For SPDM, we will discuss the topic in the last chapter.</p>
<h3 id="pcr-3">PCR 3</h3>
<p>If the option ROM or UEFI application has a setup utility which does not
require an unconditional reset, then the platform shall measure
&quot;Entering ROM Based Setup&quot; with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_ACTION</a>.
This can be done in the utility.</p>
<p>A platform may include a non-host environment, such as the Intel
Management Engine (ME). If the non-host platform can be updated by
entities other than Platform Firmware, then the non-host configuration
should be measured with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_NONHOST_CONFIG</a>
by a platform specific module.</p>
<p>A platform may include SPDM capable devices. The platform should use the
GET_MEASUREMENT command to retrieve the device firmware measurement and
measure the hardware configuration and firmware configuration with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_SPDM_FIRMWARE_CONFIG</a>
in
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_DEVICE_SECURITY_EVENT_DATA</a>.</p>
<h3 id="pcr-4">PCR 4</h3>
<p>A third party UEFI application, such as a UEFI shell utility, a standard
OS loader or an OEM boot option, is measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c" target="_blank">DxeTpm2MeasureBootLib.c</a>
<strong>Tcg2MeasurePeImage</strong>() in <strong>DxeTpm2MeasureBootHandler</strong>(). The event
type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_BOOT_SERVICES_APPLICATION</a>.
If a UEFI application is an FV which is dispatched in the DXE phase, it
is also measured to PCR4 irrespective of whether the FV is measured or
unmeasured.</p>
<p>The boot attempt action is measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>OnReadyToBoot</strong>(). Before invoking a boot option, it measures the
action \&quot;Calling EFI Application from Boot Option\&quot;. After the boot
option returns, it measures the action
\&quot;Returning from EFI Application from Boot Option\&quot;.</p>
<h3 id="pcr-5">PCR 5</h3>
<p>When a system boots a boot option in a GUID-named partition of the disk,
the GUID partition table (GPT) disk geometry needs to be measured. It is
done by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTpm2MeasureBootLib/DxeTpm2MeasureBootLib.c" target="_blank">DxeTpm2MeasureBootLib.c</a>
<strong>Tcg2MeasureGptTable</strong>() in <strong>DxeTpm2MeasureBootHandler</strong>().</p>
<p>The ExitBootServices action is measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>.
If ExitBootServices succeeds, then <strong>OnExitBootServices</strong>() is invoked.
If ExitBootServices fails, then <strong>OnExitBootServicesFailed</strong>() is
invoked.</p>
<h3 id="pcr-6">PCR 6</h3>
<p>PCR6 is for OEM specific data. The open source EDK II implementation
does not have any example to measure data to PCR6.</p>
<h3 id="pcr-7">PCR 7</h3>
<p>The UEFI secure boot related variables -- &quot;SecureBoot&quot;, &quot;PK&quot;, &quot;KEK&quot;,
&quot;db&quot;, and &quot;dbx&quot; are unconditionally measured by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>ReadAndMeasureSecureVariable</strong>(). The event type is
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_VARIABLE_DRIVER_CONFIG</a>.
If they are not present, a zero size UEFI variable entry will be
measured. The &quot;dbt&quot; and &quot;dbr&quot; variables are conditionally measured only
if they are present by the routine <strong>MeasureAllSecureVariables</strong>().</p>
<p>The UEFI secure boot variable update is measured in <a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/Variable/RuntimeDxe" target="_blank">Variable
RuntimeDxe</a>.
If any of the above secure boot related variables are updated, then
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/Variable/RuntimeDxe/Measurement.c" target="_blank">Variable RuntimeDxe
Measurement.c</a>
<strong>MeasureVariable</strong>() will measure the new data with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_VARIABLE_DRIVER_CONFIG</a>.</p>
<p>When UEFI secure boot is enabled, the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeImageVerificationLib" target="_blank">DxeImageVerificationLib</a>
verifies the PE image signature based upon the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" target="_blank">EFI_SIGNATURE_DATA</a>
in the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" target="_blank">EFI_SIGNATURE_LIST</a>
of an image signature database. If an
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" target="_blank">EFI_SIGNATURE_DATA</a>
is used to verify the image, then this
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/ImageAuthentication.h" target="_blank">EFI_SIGNATURE_DATA</a>
will be measured with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_VARIABLE_AUTHORITY</a>
in <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeImageVerificationLib/Measurement.c" target="_blank">DxeImageVerificationLib
Measurement.c</a>
<strong>MeasureVariable</strong>().</p>
<p>If a platform uses some other secure boot technology, such as Intel
BootGuard, then this secure boot policy and authority shall also be
measured into PCR7.</p>
<p>If a platform provides a firmware debugger mode, then the platform shall
measure &quot;UEFI Debug Mode&quot; string with EV_EFI_ACTION. This logic is
done at
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>MeasureSecureBootPolicy</strong>(), based upon
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdFirmwareDebuggerInitialized</a>.</p>
<p>Per Microsoft Windows requirements, a platform shall enable DMA
protection. If the DMA protection is disabled or configured to a lower
security state, then the platform shall measure the &quot;DMA Protection
Disabled&quot; string with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_ACTION</a>.
Because a platform controls the DMA protection enable/disable policy, a
platform policy driver shall measure this event.</p>
<p>If a platform uses other secure sensitive and critical configuration,
such as Intel Total Memory Encryption (TME) and System Management Mode
(SMM) protection, then the action to disable those security critical
configuration shall also be measured.</p>
<p>EV_SEPARATOR for PCR7 is handled in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>MeasureSecureBootPolicy</strong>() when the UEFI variable is ready. It is
just after <strong>MeasureAllSecureVariables</strong>(). It is earlier than the
ReadyToBoot event signal. The reason is that the PCR7
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_SEPARATOR</a>
measurement must be between secure boot policy configuration measurement
and image verification authority measurement. There might be a case
where we need to measure an UEFI image before the ReadyToBoot event. In
such an example, the authority measurement happens before the
ReadyToBoot event.</p>
<h3 id="noaction-event">NO_ACTION event</h3>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_EfiSpecIDEvent</a>
is used to describe the TCG FPF specification version. It is installed
by the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
<strong>SetupEventLog</strong>() function, based upon
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTcgPfpMeasurementRevision</a>.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_Sp800_155_PlatformId_Event2</a>
is usually installed by a platform TCG PEI or DXE module, such as
<a href="https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2/Platform800155EventPei" target="_blank">Platform800155EventPei</a>
or
<a href="https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2/Platform800155EventDxe" target="_blank">Platform800155EventDxe</a>.
A platform TCG PEIM may use
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TCG_800_155_PLATFORM_ID_EVENT_HOB</a>
for this event and it will be converted by the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>SetupEventLog</strong>() function.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_EfiStartupLocalityEvent</a>
is usually installed by a platform module in the PEI phase, such as a
BootGuard related PEIM or
<a href="https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2/StartupLocalityEventPei" target="_blank">StartupLocalityEventPei</a>.
It shall use
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TPM2_STARTUP_LOCALITY_HOB</a>
for this event and it will be converted by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
<strong>SetupEventLog</strong>() function. This NO_ACTION event is added when a
BootGuard ACM starts up the TPM device.</p>
<h3 id="event-log">Event Log</h3>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
records the event log to a
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TCG_EVENT2_HOB</a>.
The HOB will be consumed by
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
and converted into a formal TCG event log.</p>
<p>There are two ways to expose a TCG event log. The first way is via the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
<strong>GetEventLog</strong>() API. This protocol is installed by the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
module directly. Care must be taken that even after the OS calls
<strong>GetEventLog</strong>() API, a platform firmware module may add additional
event log entries, such as
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_EFI_ACTION</a>
event &quot;Exit Boot Services Invocation&quot;. Once the <strong>GetEventLog</strong>() API is
called, the additional event log is added to
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_FINAL_EVENTS_TABLE</a>.
This table is installed as a UEFI configuration table with
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_FINAL_EVENTS_TABLE_GUID</a>.</p>
<p>The second way the expose the event log is via a <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm2Acpi.h" target="_blank">TPM2
ACPI</a>
table as an optional feature. The TCG event log will be produced via
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLaml</a>
and
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLasa</a>
by
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>.
Then
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
consumes those two PCD and installs this ACPI table for the operating
system.</p>
<h3 id="hardware-root-of-trust">Hardware Root of Trust</h3>
<p>A platform may choose to use a dedicated hardware root of trust to
verify the platform firmware, such as Intel Boot Guard Technology or AMD
Platform Security Processor (PSP). If this mode is chosen, then there
should be dedicated event logs for the related component.</p>
<p>For example, if Intel Boot Guard measured boot is enabled, then the
platform shall record
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_EfiStartupLocalityEvent</a>
and may report a
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">EV_S_CRTM_CONTENTS</a>
event in PCR[0]. If Intel Boot Guard verified boot is enabled, then
the secure boot policy and authority shall also be reported in PCR[7].</p>
<h3 id="trusted-boot-chain----putting-it-all-together">Trusted Boot Chain -- Putting it all together</h3>
<p>Figure 4 shows a complete trusted boot chain that commences from a
hardware root of trust module.</p>
<h6 id="figure-4-tcg-trusted-boot-flow">Figure 4 TCG Trusted Boot Flow</h6>
<p><img src="media/image4.png" alt=""></p>
<p>For test purposes, we have a UEFI shell tool
<a href="https://github.com/jyao1/EdkiiShellTool/tree/master/EdkiiShellToolPkg/Tcg2DumpLog" target="_blank">Tcg2DumpLog</a>
to display the TCG event log. Because the event log records every step
of the PCR extend, we can reproduce the PCR values by using the digests
in the TCG event log.</p>
<p>If a developer does not have hardware, they can use a TPM2 simulator,
such as <a href="https://github.com/microsoft/ms-tpm-20-ref" target="_blank">Microsoft TPM2
simulator</a>. Currently, <a href="https://github.com/jyao1/edk2/tree/feature_tpm_emulator/EmulatorPkg/Tpm2" target="_blank">EDK
II
Tpm2Emulator</a>
can be used to communicate with the <a href="https://github.com/microsoft/ms-tpm-20-ref" target="_blank">Microsoft TPM2
simulator</a> via a socket
interface on ports 2321 and 2322. Then the developer can use the
<a href="https://github.com/jyao1/EdkiiShellTool/tree/master/EdkiiShellToolPkg/Tcg2DumpLog" target="_blank">Tcg2DumpLog</a>
to dump the TCG event log in the EDK II emulator environment.</p>
<p>The whole TPM software stack (TSS) is out of scope of this document.
There is prototype
<a href="https://github.com/flihp/edk2/tree/tpm2-tss/Tpm2TssPkg" target="_blank">Tpm2TssPkg</a> for
reference only.</p>
<h3 id="remote-attestation">Remote Attestation</h3>
<p>Remote attestation is a client/server process that helps you retrieve a
quote from the TPM. A quote is process that provides a list of the
current PCR values that are signed by the TPM.</p>
<p>A full remote attestation process includes two major steps:</p>
<ul>
<li><p>The server verifies the client TPM device.</p>
</li>
<li><p>The server verifies the TCG event log from the client.</p>
</li>
</ul>
<p>Figure 5 shows the TPM device verification flow.</p>
<p>1)  Every TPM includes an Endorsement Key (EK) signed by a root EK which
    belongs to the TPM vendor. It also includes an Attestation Key (AK).
    The client sends the TPM EK and AK to a server.</p>
<p>2)  The server verifies the EK based upon the TPM vendor root CA cert.
    The server generates a random secret and encrypts the secret and AK
    with the EK public key to be used as a challenge. Then the server
    sends the challenge to client.</p>
<p>3)  The client decrypts the secret with the EK private key and check the
    AK. Then the client sends the secret back to server.</p>
<p>4)  Now the server knows the client has a genuine TPM.</p>
<p>Figure 6 shows the event log verification.</p>
<p>1)  The server asks the client platform for a quote.</p>
<p>2)  The client platform asks the TPM to sign the PCR list with the AK
    private key as a quote. Then the client sends the quote to the
    server.</p>
<p>3)  The server verifies the signature of the quote with the AK public
    key. Now the server knows the PCR list is genuine. If the
    verification succeeds, then the server sends a request to get an
    event log.</p>
<p>4)  The client platform sends the event log directly to the server.</p>
<p>5)  The server replays the event log to reproduce the PCR values. If
    they are same, then the server knows the TCG event log is genuine.</p>
<h6 id="figure-5-remote-attestation-tpm-device-verification">Figure 5 Remote Attestation TPM Device Verification</h6>
<p><img src="media/image5.jpeg" alt=""></p>
<p>(Source: <a href="https://developer.ibm.com/articles/trusted-boot-openpower/" target="_blank">OpenPower TrustBoot</a>)</p>
<h6 id="figure-6-remote-attestation-event-log-verification">Figure 6 Remote Attestation Event Log Verification</h6>
<p><img src="media/image6.jpeg" alt=""></p>
<p>(Source: <a href="https://developer.ibm.com/articles/trusted-boot-openpower/" target="_blank">OpenPower TrustBoot</a>)</p>
<p>Once the verifier in the server gets the event log, the verifier can
compare it with the reference integrity measurement (RIM) based upon a
predefine policy.</p>
<p>Figure 7 shows the final RIM validation process.</p>
<h6 id="figure-7-rim-validation">Figure 7 RIM Validation</h6>
<p><img src="media/image7.png" alt=""></p>
<p>(source: <a href="https://trustedcomputinggroup.org/wp-content/uploads/TCG_PC_Client_FIM_v1_r40_02dec2020.pdf" target="_blank">TCG FIM</a>)</p>
<p>For test purposes, we created a sample
<a href="https://github.com/jyao1/FSP/tree/FspAttestation/Tools/ManifestTools" target="_blank">FspManifestTool</a>.
It can be used to generate a
<a href="https://csrc.nist.gov/publications/detail/nistir/8060/final" target="_blank">SWID</a> or
<a href="https://datatracker.ietf.org/doc/draft-ietf-sacm-coswid/" target="_blank">CoSWID</a> tag
for an FSP binary as the reference integrity manifest (RIM). The FSP RIM
can be used to verify the FSP binary based upon the TCG event log.</p>
<h2 id="tpm-device-startup">TPM Device Startup</h2>
<p>The platform firmware needs to send a TPM Startup command to the TPM
before measuring any data into a PCR register. TPM specification defines
three shutdown/startup sequences:</p>
<ul>
<li><strong>TPM Reset</strong> -- Tpm2Startup(CLEAR) after Tpm2Shutdown(CLEAR) or no
shutdown command is sent.</li>
</ul>
<p>All those values that are specified as having a default initialization
state go back to their default initialization state. Persistent values
that have no default initialization state are not changed.</p>
<ul>
<li><strong>TPM Restart</strong> -- Tpm2Startup(CLEAR) after Tpm2Shutdown(STATE).</li>
</ul>
<p>This preserves much of the previous state of the TPM, except the PCRs
and the controls associated with the Platform hierarchy are all returned
to their default initialization state.</p>
<ul>
<li><strong>TPM Resume</strong> -- Tpm2Startup(STATE) after Tpm2Shutdown(STATE).</li>
</ul>
<p>This preserves the previous state of the TPM, including the static Root
of Trust for Measurement (S-RTM) PCR and the platform controls other
than the PlatformHierarchyEnable.</p>
<p>Tpm2Startup(STATE) after Tpm2Shutdown(CLEAR) or no shutdown is an
invalid sequence and will fail.</p>
<p>TPM startup is done in the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>PeimEntryMA()</strong> function. <strong>Tpm2Startup</strong>(TPM_SU_CLEAR) will be used
if the system is in normal boot path, and
<strong>Tpm2Startup</strong>(TPM_SU_STATE) will be used if the system is in the S3
resume path. The issuing of the Startup command is controlled by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2InitializationPolicy</a>
because other modules may use the TPM and send a Startup command before
Tcg2Pei. One example is TPM1.2/TPM2.0 detection in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Config/Tcg2ConfigPeim.c" target="_blank">Tpm2ConfigPeim.c</a>
<strong>DetectTpmDevice</strong>(). The other example is TPM device startup in an
Intel BootGuard ACM. If the TPM is started by a BootGuard ACM, then the
platform needs to add a
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/UefiTcgPlatform.h" target="_blank">TCG_EfiStartupLocalityEvent</a>
to indicate that the startup locality is 3.</p>
<p>The platform firmware may send a TPM Shutdown command if a reset happens
in the pre-OS environment.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
registers a <strong>ShutdownTpmOnReset</strong>() callback function on the system
reset event. <strong>Tpm2Shutdown</strong>(TPM_SU_CLEAR) will be used to shut down
the TPM device.</p>
<p>The TPM measurements happen in both a normal boot path and a S4 resume.
In an S3 resume, there is no need to measure the firmware components
because the TPM state is restored in the S3 resume path. The assumption
is that the OS shall issue a <strong>Tpm2Shutdown</strong>(TPM_SU_STATE) to save
the TPM state. Then platform firmware uses
<strong>Tpm2Startup</strong>(TPM_SU_STATE) to restore the state.</p>
<p>If the OS does not send <strong>Tpm2Shutdown</strong>() or sends
<strong>TpmShutdown</strong>(TPM_SU_CLEAR), then the
<strong>Tpm2Startup</strong>(TPM_SU_STATE) will fail. Then
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
will start error handling and use <strong>Tpm2Startup</strong>(TPM_SU_CLEAR) to
start up TPM again. If the TPM can be started, then
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
will call <strong>MeasureSeparatorEventWithError</strong>() to record EV_SEPARATOR
with 0x00000001 for PCR0~7. This action is required to cap the PCR&apos;s to
an invalid state in order to resist the PCR forgery attack.</p>
<h3 id="tpm-device-selection">TPM Device Selection</h3>
<p>A platform TPM can be implemented in different ways, such as a discrete
TPM2.0 (dTPM) with either a Serial Peripheral Interface (SPI) or
Inter-Integrated Circuit (I2C) bus, a firmware TPM2.0 (fTPM), or even a
legacy TPM1.2 device. A platform needs to select the TPM device at build
time or at runtime.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TpmInstance.h" target="_blank">TPM_DEVICE_SELECTED_GUID</a>
PPI is an interface that indicates that the platform has selected the
TPM device.
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Pei" target="_blank">Tcg2Pei</a>
can run to start the TPM. If Tcg2Pei starts the TPM successfully, it
will install
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/TpmInitialized.h" target="_blank">PEI_TPM_INITIALIZED_PPI</a>
to tell other module that the TPM is initialized and ready to use. No
matter whether TPM startup succeeds or fails, Tcg2Pei always installs
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/TpmInitialized.h" target="_blank">PEI_TPM_INITIALIZATION_DONE_PPI</a>
to tell other modules that the TPM initialization process is done. Other
modules can locate
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Ppi/TpmInitialized.h" target="_blank">PEI_TPM_INITIALIZED_PPI</a>
to know if it has succeeded or failed.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Config" target="_blank">Tcg2Config</a>
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Config/TpmDetection.c" target="_blank">TpmDetection.c</a>
provides a sample implementation to detect a TPM1.2 or TPM2.0. Besides
installing
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TpmInstance.h" target="_blank">TPM_DEVICE_SELECTED_GUID</a>
PPI, it also sets
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TpmInstance.h" target="_blank">TPM_DEVICE_INTERFACE_TPM20_DTPM</a>
to
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpmInstanceGuid</a>,
which is checked by
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
to ensure that only a discrete TPM 2.0 can be supported by
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>.</p>
<p>A platform may also install the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TpmInstance.h" target="_blank">TPM_DEVICE_SELECTED_GUID</a>
PPI and set
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpmInstanceGuid</a>
directly if the configuration is fixed.</p>
<h3 id="tpm-device-interface">TPM Device Interface</h3>
<p>The main TPM specification defines the TPM commands. In EDK II, the TPM
commands are defined in
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm20.h" target="_blank">Tpm20.h</a>.</p>
<p>A TPM hardware device may support the First-In-First-Out (FIFO)
interface or Command Response Buffer (CRB). The FIFO interface defines a
set of data input/output IO registers for the TPM commands. The CRB
interface defines a chunk of DMA memory buffer for the TPM commands. In
EDK II, both the TPM FIFO and CRB interfaces are described in
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TpmPtp.h" target="_blank">TpmPtp.h</a>,</p>
<p>EDKII TCG drivers are TPM interface agnostic. They just send commands
via
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tpm2CommandLib.h" target="_blank">Tpm2CommandLib</a>.
The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/Tpm2CommandLib" target="_blank">Tpm2CommandLib</a>
implementation is also TPM interface agnostic and sends command to
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tpm2DeviceLib.h" target="_blank">Tpm2DeviceLib</a>.
The Tpm2DeviceLib abstracts how to send a TPM command. For example,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/Tpm2DeviceLibTcg2" target="_blank">Tpm2DeviceLibTcg2</a>
is the instance to send a TPM command via
EFI_TCG2_PROTOCOL.SubmitCommand().
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/Tpm2DeviceLibDTpm" target="_blank">Tpm2DeviceLibDTpm</a>
is the instance to send a TPM command to the hardware via FIFO or CRB.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2DeviceLibDTpm.c" target="_blank">Tpm2DeviceLibDTpm.c</a>
detects the TPM device interface type in <strong>Tpm2GetPtpInterface</strong>(). It
checks the FIFO and CRB register to know the device interface. Then this
function sets the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>.
Then</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2DeviceLibDTpm.c" target="_blank">Tpm2DeviceLibDTpm.c</a>
detects the TPM device interface type in <strong>Tpm2GetPtpInterface</strong>(). It
checks the FIFO and CRB register to know the device interface. Then this
function sets the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/Tpm2DeviceLibDTpm" target="_blank">Tpm2DeviceLibDTpm</a>
sends a TPM command in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2Ptp.c" target="_blank">Tpm2Ptp.c</a>
<strong>DTpm2SubmitCommand</strong>(). It checks
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>
and calls
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2Tis.c" target="_blank">Tpm2Tis.c</a>
<strong>Tpm2TisTpmCommand</strong>() for the FIFO interface or
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/Tpm2DeviceLibDTpm/Tpm2Ptp.c" target="_blank">Tpm2Ptp.c</a>
<strong>PtpCrbTpmCommand</strong>() for the CRB interface.</p>
<p>Figure 8 shows the TCG trusted boot component in EDK II.</p>
<h6 id="figure-8-tcg-trusted-boot-component-in-edk-ii">Figure 8 TCG Trusted Boot Component in EDK II</h6>
<p><img src="media/image8.png" alt=""></p>
<h3 id="error-handling">Error Handling</h3>
<p>TPM errors may happen at any time. According to the TCG specification,
capping PCR is always required. If the PCR cannot be capped, the
platform SHOULD take any necessary action to notify the host platform&apos;s
administrator, user, and operator of this situation and transition to a
&quot;fail-safe&quot; mode by performing one of these actions:</p>
<ul>
<li><p>Make the TPM interface inaccessible via hardware for the remainder
of the power cycle</p>
</li>
<li><p>Reboot the Host Platform</p>
</li>
<li><p>Disable the Host Platform</p>
</li>
<li><p>Perform a vendor-specific action that is equivalent to one of the
options above.</p>
</li>
</ul>
<p>When a TPM returns an error,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
will create a
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TPM_ERROR</a>
HOB and report the error status code via <strong>REPORT_STATUS_CODE</strong>() with
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdStatusCodeSubClassTpmDevice</a>.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
will detect the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/TcgEventHob.h" target="_blank">EFI_TPM_ERROR</a>
HOB and not install
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
if there is a TPM error. If the TPM error happens after the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
installation,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
will set the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.TPMPresentFlag</a>
to be FALSE. At this point the OS will know the TPM is absent. Similar
to
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
also reports the error status code via <strong>REPORT_STATUS_CODE</strong>().</p>
<p>A platform module may register a ReportStatusCode callback handler to
process the TPM error, such as reset system, or disable the TPM
hardware.</p>
<h2 id="tcg-physical-presence">TCG Physical Presence</h2>
<p>TCG Physical Presence (PP) interface is a way to let an OS send a
request to configure the TPM device, such as Clear, SetPCRBanks,
ChangeEPS, Enable, Disable, DisableEndorsementEnableStorageHierarchy.
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TcgPhysicalPresence.h</a>
lists all TCG PP operation defined by the TCG PP specification.</p>
<p>EDK II defines a
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PhysicalPresenceLib.h" target="_blank">Tcg2PhysicalPresenceLib</a>
to abstract the TCG PP functions. It has three instances -
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/PeiTcg2PhysicalPresenceLib" target="_blank">PeiTcg2PhysicalPresenceLib</a>,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/DxeTcg2PhysicalPresenceLib" target="_blank">DxeTcg2PhysicalPresenceLib</a>,
and
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/SmmTcg2PhysicalPresenceLib" target="_blank">SmmTcg2PhysicalPresenceLib</a>.
The TCG PP related ACPI code is at
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">Tpm.asl</a>
of the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
driver.</p>
<p>During boot,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.c" target="_blank">Tcg2Smm.c</a>
<strong>PublishAcpiTable</strong>() allocates the non-volatile storage ACPI OpRegion</p>
<ul>
<li>mTcgNvs for
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">ASL</a>/SMM
communication. At runtime, the OS locates the TPM device - <strong>Name</strong>(CID,
\&quot;MSFT0101\&quot;) and calls the <strong>_DSM</strong>() method. The first parameter is a
UUID. The value (3dddfaa6-361b-4eb4-a424-8d10089d1653) means the
function call is TCG PP request. Finally, the <strong>TPPI</strong>() method fills
the parameter in the <strong>OperationRegion</strong>(TNVS) and triggers the SMI -
<strong>Store</strong>(PPIN, IOPN).</li>
</ul>
<p>Then
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.c" target="_blank">Tcg2Smm.c</a>
<strong>PhysicalPresenceCallback</strong>() will be triggered to handle such a PP
request. It checks the parameters and calls the corresponding function
in
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/SmmTcg2PhysicalPresenceLib" target="_blank">SmmTcg2PhysicalPresenceLib</a>.
EDK II defines two PP variables:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable. It is a read/write variable because anyone can send the PP
request. The data structure is
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">EFI_TCG2_PHYSICAL_PRESENCE</a>.
This variable is to record the TCG PP request, request parameter,
and finally, the response result.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
variable. It is a read-only variable to prevent modification from
malicious software. The data structure is
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">EFI_TCG2_PHYSICAL_PRESENCE_FLAGS</a>.
This variable is to record the TCG management flags. The flags are
defined in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PhysicalPresenceLib.h" target="_blank">Tcg2PhysicalPresenceLib</a>,
such as TCG2_BIOS_TPM_MANAGEMENT_FLAG_xxx,
TCG2_BIOS_INFORMATION_FLAG_xxx,
TCG2_BIOS_STORAGE_MANAGEMENT_FLAG_xxx.</p>
</li>
</ul>
<p>If the OS submits a TPM configuration change request, then this request
is saved in the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable.</p>
<p>Upon the next boot, a PlatformBds module, such as
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/BoardModulePkg/Library/BoardBdsHookLib/BoardBdsHookLib.c" target="_blank">BoardBdsHookLib</a>,
needs to process the TCG PP request. <strong>ProcessTcgPp</strong>() needs to check
<strong>Tcg2PhysicalPresenceLibNeedUserConfirm</strong>(), connect the platform
specific trusted console if user confirmation is required, and then call
<strong>Tcg2PhysicalPresenceLibProcessRequest</strong>().</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTcg2PhysicalPresenceLib/DxeTcg2PhysicalPresenceLib.c" target="_blank">DxeTcg2PhysicalPresenceLib.c</a>
implements the <strong>Tcg2PhysicalPresenceLibProcessRequest</strong>(). It calls
<strong>VariableLockProtocol</strong>-&gt;<strong>RequestToLock</strong>() to lock the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
variable, reads
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable, and then calls <strong>Tcg2ExecutePendingTpmRequest</strong>() to process
the request. If user confirmation is required, then
<strong>Tcg2UserConfirm</strong>() is called. Once the configuration is confirmed,
the TPM is configured in <strong>Tcg2ExecutePhysicalPresence</strong>(), such as
Clear, SetPCRBanks, ChangeEPS, LogAllDigests. After configuration,
<strong>Tcg2ExecutePendingTpmRequest</strong>() then records the new configuration in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
variable and the PP result in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable. Finally, this function will reset the system in order to make
the new settings take effect.</p>
<p>Please be aware that <strong>Tcg2PhysicalPresenceLibProcessRequest</strong>() shall
be called before EndOfDxe event because the read-only
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
variable can only be updated before EndOfDxe.</p>
<p>Once the PP request is processed, the OS may use ACPI <strong>_DSM</strong>() method
again to get the result.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tcg2Smm.c" target="_blank">Tcg2Smm.c</a>
<strong>PhysicalPresenceCallback</strong>() will return the result from
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable.</p>
<h3 id="tpm-bank-selection">TPM Bank Selection</h3>
<p>A TPM device may have multiple banks of PCRs. A PCR bank is a collection
of PCRs that are extended with the same hash algorithm. PCR banks are
identified by the hash algorithm used to extend the PCR in that bank.</p>
<p>The PP operation
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_SET_PCR_BANKS</a>
can be used to configure the active PCR banks.</p>
<p>Besides the PP request, the OS may use
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
for TPM active bank management as well. <strong>GetActivePcrBanks</strong>() returns
the current active banks. <strong>SetActivePcrBanks</strong>() is used to set the new
PCR banks request. It does not take effect immediately, but just saves a
request. The new PCR bank setting request will be processed in the next
boot. <strong>GetResultOfSetActivePcrBanks</strong>() is used to get the new PCR
banks setting result.</p>
<p>EDK II
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
just uses the same
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresence</a>
variable for the implementation. Later
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTcg2PhysicalPresenceLib/DxeTcg2PhysicalPresenceLib.c" target="_blank">DxeTcg2PhysicalPresenceLib.c</a>
calls <strong>Tcg2ExecutePhysicalPresence</strong>() and then
<strong>Tpm2GetCapabilitySupportedAndActivePcrs</strong>() in order to get the
current supported PCR banks and compares them. If one of the new PCR
banks is not supported, then the request will be rejected. Otherwise,
this function calls <strong>Tpm2PcrAllocateBanks</strong>() to set the new banks and
then reset the system.</p>
<p>Care must be taken that the final active PCR banks value is based upon
multiple criteria:</p>
<p>1)  TPM supported PCR banks - It can be retrieved from
    <strong>Tpm2GetCapabilitySupportedAndActivePcrs</strong>(&amp;TpmHashAlgorithmBitmap).</p>
<p>2)  TPM end user desired current active PCR banks -- It can also be
    retrieved from
    <strong>Tpm2GetCapabilitySupportedAndActivePcrs</strong>(&amp;TpmActivePcrBanks).</p>
<p>3)  The OEM configuration supported active PCR banks -- the OEM may
    select a subset of hash algorithms. It is recorded in
    <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>.</p>
<p>4)  The platform firmware software capability -- the OEM may select a
    subset of hash algorithms. It is recorded in
    <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>.</p>
<p>The final effective PCR banks is a subset of all of them. For example,
take a TPM that supports SHA256|SHA384|SM3_256. The end user desired
active PCR bank is SHA256. The supported active PCR banks is
SHA256|SHA384. The platform firmware software capability is
SHA256|SHA384. Then the final effective PCR banks is SHA256 only.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Pei/Tcg2Pei.c" target="_blank">Tcg2Pei.c</a>
<strong>SyncPcrAllocationsAndPcrMask</strong>() function is used to synchronize the
settings. This includes ensuring that the TPM has appropriate hardware
capability (TpmHashAlgorithmBitmap), the current active PCR banks
(TpmActivePcrBanks), and the supported active PCR banks
(<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>).
These all need to be in agreement.</p>
<ul>
<li><p>If there is a bank in TpmActivePcrBanks that is not described in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>,
then it means that the OEM does not want to enable this bank.
<strong>SyncPcrAllocationsAndPcrMask</strong>() will call
<strong>Tpm2PcrAllocateBanks</strong>() to remove the bank from the active PCR
banks and reset the system.</p>
</li>
<li><p>If there is a bank in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
but not supported in the TpmHashAlgorithmBitmap, that means the OEM
configured an invalid bank. <strong>SyncPcrAllocationsAndPcrMask</strong>() will
update
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>.</p>
</li>
</ul>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
serves as an indicator of the supported active PCR banks. It will be
used to guide
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>
generation and during the hash algorithm registration in
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashLibBaseCryptoRouter" target="_blank">HashLibBaseCryptoRouter</a>.
A platform may register multiple hash algorithms, such as
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha256" target="_blank">HashInstanceLibSha256</a>,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha384" target="_blank">HashInstanceLibSha384</a>,
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSha512" target="_blank">HashInstanceLibSha512</a>
and
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/HashInstanceLibSm3" target="_blank">HashInstanceLibSm3</a>.
If a hash algorithm is not indicated in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>,
this hash algorithm will not be registered successfully. The final
registered hash algorithms value is a subset of
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
and is recorded in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>.</p>
<p>Figure 9 shows the TPM bank selection in EDK II.</p>
<h6 id="figure-9-tpm-bank-selection-in-edk-ii">Figure 9 TPM Bank Selection in EDK II</h6>
<p><img src="media/image9.png" alt=""></p>
<p>In brief, we have below result:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
(supported active PCR banks) must be a subset of
TpmHashAlgorithmBitmap (TPM capability).</p>
</li>
<li><p>TpmActivePcrBanks (end user desired active PCR banks) must be a
subset of
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>
(platform firmware capability) must be a subset of
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>.</p>
</li>
</ul>
<p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>
serves as an indicator of the firmware hash algorithm capability.
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Dxe/Tcg2Dxe.c" target="_blank">Tcg2Dxe.c</a>
needs to report the capability to the OS with the following values:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.HashAlgorithmBitmap</a>
shall be the (TpmHashAlgorithmBitmap &amp;
PcdGet32 (PcdTcg2HashAlgorithmBitmap))</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.ActivePcrBanks</a>
shall be the (TpmActivePcrBanks &amp;
PcdGet32 (PcdTcg2HashAlgorithmBitmap))</p>
</li>
</ul>
<p>In the above example, we have following configuration:</p>
<ul>
<li><p>TpmHashAlgorithmBitmap is SHA256|SHA384|SM3_256.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2HashMask</a>
is SHA256|SHA384.</p>
</li>
<li><p>TpmActivePcrBanks is SHA256.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcg2HashAlgorithmBitmap</a>
is SHA256|SHA384.</p>
</li>
</ul>
<p>The final report is:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.HashAlgorithmBitmap</a>
is SHA256|SHA384.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_BOOT_SERVICE_CAPABILITY.ActivePcrBanks</a>
is SHA256.</p>
</li>
</ul>
<p>Then the end user may have chance to enable SHA384 for the platform.</p>
<h3 id="tpm-hierarchy-management">TPM Hierarchy Management</h3>
<p>TPM has three hierarchies -- platform hierarchy, storage hierarchy and
endorsement hierarchy.</p>
<p>The platform hierarchy is managed by the platform firmware. Before
booting to the OS, the platform firmware shall randomize the platform
hierarchy auth value in order to prevent another entity from accessing
the platform hierarchy.</p>
<p>A sample implementation of this randomization can be found in the
<a href="https://github.com/tianocore/edk2-platforms/tree/master/Platform/Intel/MinPlatformPkg/Tcg" target="_blank">Tcg2Platform</a>
module in EDK II platform repository. In a normal boot path,
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/MinPlatformPkg/Tcg/Tcg2PlatformDxe/Tcg2PlatformDxe.c" target="_blank">Tcg2PlatformDxe.c</a>
calls <strong>ConfigureTpmPlatformHierarchy</strong>() in
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/MinPlatformPkg/Tcg/Library/TpmPlatformHierarchyLib/TpmPlatformHierarchyLib.c" target="_blank">TpmPlatformHierarchyLib.c</a>
to randomize the platform auth value in EndOfDxe event. Once the
<strong>Tpm2HierarchyChangeAuth</strong>() command is sent to the TPM, no one else
can use the platform hierarchy without knowing the random number. In the
S3 resume path, there is no need to randomize the platform auth value
again if the Tcg2Pei resumes TPM successfully. However, if a TPM resume
fails and Tcg2Pei needs to restart the TPM, then
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/MinPlatformPkg/Tcg/Tcg2PlatformPei/Tcg2PlatformPei.c" target="_blank">Tcg2PlatformPei.c</a>
<strong>RandomizePlatformAuth</strong>() is called to randomize the platform auth
value in the EndOfPei event <strong>PlatformInitEndOfPei</strong>() before the
platform firmware resumes to the OS.</p>
<p>The OS manages the storage hierarchy, which is independent of the
platform hierarchy. The OS may ask the platform auth to clear the TPM
via TCG PP operation
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_CLEAR</a>.
Later
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Library/DxeTcg2PhysicalPresenceLib/DxeTcg2PhysicalPresenceLib.c" target="_blank">DxeTcg2PhysicalPresenceLib.c</a>
calls <strong>Tcg2ExecutePhysicalPresence</strong>() then <strong>Tpm2CommandClear</strong>() to
clear the TPM.</p>
<p>Other PP operations such as
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_ENABLE</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_DISABLE</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/TcgPhysicalPresence.h" target="_blank">TCG2_PHYSICAL_PRESENCE_DISABLE_ENDORSEMENT_ENABLE_STORAGE_HIERARCHY</a>
can be used to enable or disable the storage hierarchy or the
endorsement hierarchy. These are optional features. If they are
implemented, then Tcg2Pei needs to call the
<strong>Tcg2PhysicalPresenceLibGetManagementFlags</strong>() function from
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Library/PeiTcg2PhysicalPresenceLib" target="_blank">PeiTcg2PhysicalPresenceLib</a>,
check TCG2_BIOS_INFORMATION_FLAG_HIERARCHY_CONTROL_xxx flags in
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PhysicalPresenceLib.h" target="_blank">Tcg2PhysicalPresenceLib</a>
and send <strong>Tpm2HierarchyControl</strong>() command to enable or disable the
hierarchy.</p>
<p>TCG PP Interface not only controls TPM configuration, but it also
controls the TCG storage configuration, such as BlockSid. We will
discuss that in TCG storage section.</p>
<p>TCG PP interface also supports vendor specific extensions. EDK II
defines
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PpVendorLib.h" target="_blank">Tcg2PpVendorLib</a>
to serve that purpose.</p>
<p>Figure 10 shows TCG PP component in EDK II.</p>
<h6 id="figure-10-tcg-pp-component-in-edk-ii">Figure 10 TCG PP Component in EDK II</h6>
<p><img src="media/image10.png" alt=""></p>
<h2 id="tcg-memory-overwrite-mor">TCG Memory Overwrite (MOR)</h2>
<p>The memory overwrite (MOR) feature is to mitigate the platform reset
attack. It is not related to the TPM hardware but is a pure software
feature.</p>
<p>The TCG Platform Reset Mitigation specification defines two UEFI
variables:</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/MemoryOverwriteControl.h" target="_blank">MemoryOverwriteRequestControl</a>
variable (MOR variable). It is a read/write variable. This variable
is to record the TCG MOR request state.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/MemoryOverwriteRequestControlLock.h" target="_blank">MemoryOverwriteRequestControlLock</a>
variable (MorLock variable). It is lockable in some situations to
prevent modification from malicious software. This variable is to
control the lock state of
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/MemoryOverwriteControl.h" target="_blank">MemoryOverwriteRequestControl</a>
variable and itself. It can be accessed with a UEFI variable service
-- SetVariable()/GetVariable(). But it is not a normal UEFI variable
because it cannot be stored on flash region even though it has the
NON_VOLATILE attribute. It is more like a virtual variable.</p>
</li>
</ul>
<p>A platform memory initialization module shall check the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/MemoryOverwriteControl.h" target="_blank">MemoryOverwriteRequestControl</a>
variable. If this variable is not present or this variable indicates a
MOR request, then the memory initialization module shall clear the
memory after enabling the memory controller. For example, the
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/QuarkPlatformPkg/Platform/Pei/PlatformInit/MrcWrapper.c" target="_blank">QuarkPlatformMemoryInit</a>
module <strong>InstallEfiMemory</strong>() function checks the MOR variable and zeros
all system memory before installing it if MOR_CLEAR_MEMORY_VALUE() is
TRUE. Another example is the Kabylake openboard
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/KabylakeOpenBoardPkg/KabylakeRvp3/FspWrapper/Library/PeiSiliconPolicyUpdateLibFsp/PeiFspMiscUpdUpdateLib.c" target="_blank">FspmPolicyWrapper</a>
<strong>PeiFspMiscUpdUpdatePreMem</strong>() function that checks the MOR variable
and sets the CleanMemory policy data if MOR_CLEAR_MEMORY_BIT_MASK is
set.</p>
<p>The MOR variable is managed by the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/MemoryOverwriteControl" target="_blank">MemoryOverwriteControl</a>
module. The MOR variable is created at
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/MemoryOverwriteControl/TcgMor.c" target="_blank">TcgMor.c</a>
entrypoint <strong>MorDriverEntryPoint</strong>(), and the variables is cleared at
the ReadyToBoot event <strong>OnReadyToBoot</strong>().</p>
<p>Because the MOR variable is read/write, a malicious software entity may
just clear the MOR request even if a high privileged software requests
the MOR. We need a secure MOR solution to prevent such an attack. The
MorLock variable was introduced to protect the MOR variable. The first
version of MorLock is simple. Once the MorLock is set, no one can unlock
MOR until the next boot. It is secure, but it brings performance
overhead for a system reset. People have to wait a long time for the
platform memory module cleaning all system memory, especially on a
server platform with large memory. The second MorLock supports unlock.
The MorLock caller can set MorLock with an 8 byte secret key. If the
caller sets MorLock with the same 8 bytes secret key, it means unlock
MOR. In order to prevent secret key guessing, any wrong secret key will
cause the MorLock to become unlockable in the current boot.</p>
<p>Because the variable driver must save a secret key, the variable driver
shall:</p>
<p>1)  execute in a secure execution environment, such as system management
    mode (SMM).</p>
<p>2)  not store the secret key content to a non-volatile storage, such as
    an SPI flash region.</p>
<p>The MorLock variable is managed by the EDKII
<a href="https://github.com/tianocore/edk2/tree/master/MdeModulePkg/Universal/Variable/RuntimeDxe" target="_blank">VariableRuntimeDxe</a>
driver
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Universal/Variable/RuntimeDxe/TcgMorLockSmm.c" target="_blank">TcgMorLockSmm.c</a>.
<strong>SetVariableCheckHandlerMorLock</strong>() function follows the specification
to handle both secure MOR version 1 (lock without key) and version 2
(lock with key).</p>
<p>Figure 11 shows the high level TCG MOR Flow.</p>
<h6 id="figure-11-tcg-mor-flow">Figure 11 TCG MOR Flow</h6>
<p><img src="media/image11.png" alt=""></p>
<p>The MOR variable not only control memory overwrite but also control the
storage device TPer reset. We will discuss that in TCG storage section.</p>
<p>Previous MOR specifications also defined an ACPI interface. The OS may
set MOR state by using an ACPI _DSM method. This interface is
deprecated because it does not support secure MOR. Figure 12 shows TCG MOR component in EDK II.</p>
<h6 id="figure-12-tcg-mor-component-in-edk-ii">Figure 12 TCG MOR Component in EDK II</h6>
<p><img src="media/image12.png" alt=""></p>
<h2 id="os-interface">OS Interface</h2>
<p>A platform firmware shall report the TPM device to an OS. The report
should include 1) ACPI table, 2) EFI_TCG2_PROTOCOL.</p>
<h3 id="acpi-table">ACPI Table</h3>
<p>A TPM capable system shall report two ACPI tables.</p>
<p>1)  <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm2Acpi.h" target="_blank">TPM2
    ACPI</a>
    table -- This is a static table to report the TPM device control
    area and TCG event log.</p>
<p>2)  <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">TPM
    SSDT</a>
    ACPI table -- This is the ACPI language to declare the TPM device,
    describe the hardware resources, such as interrupt information, and
    provide the device specific method _DSM(), such as TCG Physical
    Presence (PP) operation.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
installs <a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/IndustryStandard/Tpm2Acpi.h" target="_blank">TPM2
ACPI</a>
table in <strong>PublishTpm2</strong>(). It uses the below PCDs to patch the table.</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableRev</a> -
This is to indicate TPM2 ACPI table version: version 3 or version 4.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdTpmPlatformClass</a> -
This is to indicate the platform type: client or server.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLaml</a>/<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2AcpiTableLasa</a>
-- This is for TCG event log area. Only version 4 table includes the
TCG event log field.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdActiveTpmInterfaceType</a>
-- These are for the TPM device interface: Tpm2PtpInterfaceCrb or
Tpm2PtpInterfaceFifo. Only Tpm2PtpInterfaceCrb interface requires
StartMethod and AddressOfControlArea.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpmBaseAddress</a>
-- This is for TPM device base address.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultOemId</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultOemTableId</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultOemRevision</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultCreatorId</a>,
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultCreatorRevision</a>
-- These are for the common ACPI header.</p>
</li>
</ul>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
installs the <a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Tcg2Smm/Tpm.asl" target="_blank">TPM
SSDT</a>
ACPI table in <strong>PublishAcpiTable</strong>(). It uses the below PCDs to patch
the table.</p>
<ul>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTcgPhysicalPresenceInterfaceVer</a>
-- This is to indicate the TCG Physical Presence Interface version.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2CurrentIrqNum</a>,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdTpm2PossibleIrqNumBuf</a>
-- This is to indicate the TPM IRQ information.</p>
</li>
<li><p><a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/MdeModulePkg.dec" target="_blank">PcdAcpiDefaultOemId</a>
-- This is for the common ACPI header. The OemTableId and
OemRevision should not be patched because they are defined at build
time -- &apos;TPM2Tabl&apos;. The CreatorId and CreatorRevision should not be
patched because the ASL compiler fills in those values.</p>
</li>
</ul>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
patches the TNVS ACPI OperationRegion with an ACPInvs memory address in
<strong>AssignOpRegion</strong>(). The TNVS is used as a runtime communication buffer
between ASL and the SMI handler <strong>PhysicalPresenceCallback</strong>() for the
TCG PP request.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Smm" target="_blank">Tcg2Smm</a>
patches _HID to indicate a TPM device to the OS in <strong>UpdateHID</strong>().
Tcg2Smm should get the TPM
<a href="https://trustedcomputinggroup.org/resource/vendor-id-registry/" target="_blank">vendorID</a>
from the <strong>Tpm2GetCapabilityManufactureID</strong>(), then translate the TPM
vendorID to the ACPI defined <a href="https://uefi.org/PNP_ACPI_Registry" target="_blank">PNPID</a>
and update the _HID name string. In a case that a company only
registered a TPM vendorID but not an ACPI PNPID, the translation fails.
The _CID(&quot;MSFT0101&quot;) should be used as _HID.</p>
<h3 id="tcg2protocol">TCG2_PROTOCOL</h3>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
is to provide a TCG services to an OS loader. It is a boot service
protocol. It cannot be used after the ExitBootServices event.</p>
<p><a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Tcg2Dxe" target="_blank">Tcg2Dxe</a>
installs the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/Tcg2Protocol.h" target="_blank">EFI_TCG2_PROTOCOL</a>
and provides the below services:</p>
<ul>
<li><p><strong>GetCapability</strong>() -- This is to return capability information and
state information, such as HashAlgorithmBitmap, SupportedEventLogs,
TPMPresentFlag, NumberOfPCRBanks, ActivePcrBanks, etc.</p>
</li>
<li><p><strong>GetEventLog</strong>() -- This is to return the TCG event log.</p>
</li>
<li><p><strong>HashLogExtendEvent</strong>() -- This is to provide a service to extend
data and log events. It has a flag to measure a PE image directly.</p>
</li>
<li><p><strong>SubmitCommand</strong>() -- This is to submit a TPM command.</p>
</li>
<li><p><strong>GetActivePcrBanks</strong>() -- This is to get the active PCR banks.</p>
</li>
<li><p><strong>SetActivePcrBanks</strong>() -- This is to set the active PCR banks. It
will not take effect until the next reboot.</p>
</li>
<li><p><strong>GetResultOfSetActivePcrBanks</strong>() -- This is to return the result
of the last <strong>SetActivePcrBanks</strong>().</p>
</li>
</ul>
<h2 id="tcg-storage">TCG Storage</h2>
<p>The TCG not only defines the TPM device, but it also defines storage
devices, such as OPAL, Opalite, Pyrite, and Ruby.</p>
<p>EDK II
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/TcgStorageCoreLib.h" target="_blank">TcgStorageCoreLib</a>
provides interfaces for TCG storage, including the lowest level TCG data
encoding, such as TcgStartComPacket(), TcgEndComPacket(),
TcgStartPacket(), TcgEndPacket(), TcgStartSubPacket(),
TcgEndSubPacket(), TcgAddUINT8(), TcgAddUINT64(), TcgAddBOOLEAN(),
TcgAddTcgUid(), etc.</p>
<p>EDK II
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/TcgStorageOpalLib.h" target="_blank">TcgStorageOpalLib</a>
provides interfaces for TCG OPAL commands, such as OpalStartSession(),
OpalEndSession(), OpalPsidRevert(), OpalGetMsid(), OpalSetPassword(),
OpalBlockSid(), etc.</p>
<p><a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/StorageSecurityCommand.h" target="_blank">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a>
is used to send a storage security command to a secure storage device.</p>
<p>The EDK II
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver handles all TCG storage features, such as OPAL device password
management and BlockSid.</p>
<h3 id="opal-password">OPAL Password</h3>
<p>The OPAL password feature is designed to replace the Hard Disk Drive
(HDD) password in the Advanced Technology Attachment (ATA)
specification. It lets a user set a password for the disk during
provisioning and requests the same password during every subsequent boot
to unlock the disk.</p>
<p>The EDK II
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver provides a setup user interface (UI) to let a user to input a
password to unlock the disk. At the driver entrypoint,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalDriver.c" target="_blank">OpalDriver.c</a>
<strong>EfiDriverEntryPoint</strong>() installs the DriverBinding protocol and calls
<strong>HiiInstall</strong>() to install the setup form. Whenever there is an storage
device discovered, <strong>OpalEfiDriverBindingSupported</strong>() will check if the
device supports
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Protocol/StorageSecurityCommand.h" target="_blank">EFI_STORAGE_SECURITY_COMMAND_PROTOCOL</a>.
If supported, then <strong>OpalEfiDriverBindingStart</strong>() calls
<strong>OpalDiskInitialize</strong>() to initialize the device, such as getting
manufactured SID (MSID) and data removal mechanism information. Then
<strong>OpalEfiDriverBindingStart</strong>() calls <strong>OpalDriverRequestPassword</strong>() to
unlock the disk.</p>
<p>If the disk locking feature is not set, then there is no need to ask the
user to input a password. The function just returns.</p>
<p>If the disk locking feature is set, the disk will be in the locked
state. A password dialogue box will be pop up to ask user to input the
password. Then <strong>OpalDriverRequestPassword</strong>() calls
<strong>OpalUtilUpdateGlobalLockingRange</strong>() to try unlocking. If the disk is
unlocked, then the password is correct. It will be used for
auto-unlocking in S3 resume (we will discuss that later). If unlocking
fails, then the user will be asked to input the password again. The
maximum retry count is 5 times. After that, the system will shut down.</p>
<p>A system level cold reset causes disk device power off, in which case
the disk is locked. However, a warm reset may keep the disk device power
on, which cause the disk remaining in the unlocked state after reset. In
this condition, the OpalPassword driver still need to get the password
from the end user for auto-unlocking in S3 resume. As such,
<strong>OpalDriverRequestPassword</strong>() calls
<strong>OpalUtilUpdateGlobalLockingRange</strong>() to try locking the device. If the
user does not input the original password, the action will not success.
Once the disk is locked, then the password is correct.
<strong>OpalUtilUpdateGlobalLockingRange</strong>() is called again to unlock the
disk.</p>
<p>Sometimes, the platform may want to skip the OPAL password prompt. It
can be controlled by
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/SecurityPkg.dec" target="_blank">PcdSkipOpalPasswordPrompt</a>.
An end user may also choose to skip the password input by using &apos;ESC&apos;.
In this password skip scenario, if the device is in the locked state,
the device will be kept in the locked state and continue booting. If the
device is unlocked, the system will be forced to shut down in order to
lock the device again.</p>
<p>OPAL disk auto-unlocking in S3 resume is a necessary feature because
there is no UI available in the S3 resume path to let an end user input
anything. What we need is to let the DXE OPAL driver save the password
to a secure place with confidentiality guarantee, and then another S3
resume OPAL driver can get the password and unlock the OPAL device. The
system management RAM (SMRAM) is a natural place to save the password
secret. There are two possible ways to achieve this:</p>
<ul>
<li><p>We can have an SMM OPAL password driver. The DXE OPAL driver passes
the password to the SMM OPAL driver on a normal boot. Then the PEI
S3 script uses a software system management interrupt (SMI) invokes
the SMM OPAL driver to unlock the device.</p>
</li>
<li><p>We can have a PEI OPAL password driver. The DXE OPAL driver saves
the password to a
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Include/Library/LockBoxLib.h" target="_blank">LockBox</a>
with a confidentiality attribute. The password won&apos;t be exposed by
an OS and it can only be retrieved in PEI S3 code. Each LockBox can
be uniquely identified by a GUID. As such, the PEI OPAL driver gets
the password from the same LockBox during the S3 resume and unlocks
the device.</p>
</li>
</ul>
<p>In the first version, we choose the SMM OPAL password solution. However,
we ran into complicated Direct Memory Access (DMA) protection issues
because it is complicated to enable I/O Memory Management Unit (IOMMU)
for device DMA protection inside of SMM. So now we choose the PEI OPAL
password solution. In a normal boot path, at EndOfDxe event
<strong>OpalEndOfDxeEventNotify</strong>(), the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalDriver.c" target="_blank">OpalDriver.c</a>
<strong>BuildOpalDeviceInfo</strong>() routine collects all OPAL device and password
information and saves this to the OpalDevice LockBox and S3InitDevice
LockBox via <strong>SaveLockBox</strong>() and sets the confidentiality attribute via
<strong>SetLockBoxAttributes</strong>(LOCK_BOX_ATTRIBUTE_RESTORE_IN_S3_ONLY).
The OPAL password unlock must happen before EndOfDxe event because the
LockBox services are closed after EndOfDxe.</p>
<p>In the S3 resume path,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalPasswordPei.c" target="_blank">OpalPasswordPei.c</a>
entry point <strong>OpalPasswordPeiInit</strong>() installs the
<a href="https://github.com/tianocore/edk2/blob/master/MdeModulePkg/Include/Ppi/StorageSecurityCommand.h" target="_blank">EDKII_PEI_STORAGE_SECURITY_CMD_PPI</a>.
Whenever there is a disk driver installed, the
<strong>OpalPasswordStorageSecurityPpiNotify</strong>() callback function is invoked.
Then <strong>UnlockOpalPasswordDevices</strong>() gets the LockBox information via
<strong>RestoreLockBox</strong>() and calls <strong>UnlockOpalPassword</strong>() to unlock the
device one by one.</p>
<h3 id="opal-features">OPAL Features</h3>
<p>An end user may want to update the OPAL password for a device. Usually,
an end user can go to the BIOS setup page to perform that action and the
new password will take effect immediately. However, that is not feasible
in the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver. Because the setup page is launched after EndOfDxe event, there
is no chance to save the new password for auto-unlocking. As such, the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver only allows the user to send a request and then reset the system.
The OPAL password update request will be served in the next boot. After
the disk is unlocked, the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalDriver.c" target="_blank">OpalDriver.c</a>
<strong>OpalEfiDriverBindingStart</strong>() routine calls <strong>ProcessOpalRequest</strong>().</p>
<p>Besides the password update, the
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/Opal/OpalPassword" target="_blank">OpalPassword</a>
driver supports an additional set of requests, such as:</p>
<ul>
<li><p><strong>ProcessOpalRequestSetAdminPwd</strong>() -- Set admin password. The old
admin password is required here.</p>
</li>
<li><p><strong>ProcessOpalRequestSetUserPwd</strong>() -- Set user password. The old
user password is required here.</p>
</li>
<li><p><strong>ProcessOpalRequestSecureErase</strong>() -- Secure erase user data on the
disk. An admin or user password is required here.</p>
</li>
<li><p><strong>ProcessOpalRequestRevert</strong>() -- Admin based revert to factory
default. The admin password and manufactured SID (MSID) is required
here. MSID can be read via <strong>OpalUtilGetMsid</strong>(). The admin can
choose to keep the user data or destroy it.</p>
</li>
<li><p><strong>ProcessOpalRequestPsidRevert</strong>() -- Physical Presence SID (PSID)
based revert to factory default. PSID is a 32-character case
sensitive value that is shipped with the disk.</p>
</li>
<li><p><strong>ProcessOpalRequestDisableUser</strong>() -- Disable user. The admin
password is required here.</p>
</li>
<li><p><strong>ProcessOpalRequestEnableFeature</strong>() -- Enable OPAL feature. The
admin password and MSID are required here.</p>
</li>
</ul>
<p>Care must be taken given that the OPAL device may take long to finish an
Erase or Revert action. To give a better user experience, the OPAL
driver pops up a message to notify the user of this potential delay.</p>
<p>Figure 13 shows TCG storage component in EDK II.</p>
<h6 id="figure-13-tcg-storage-component-in-edk-ii">Figure 13 TCG Storage Component in EDK II</h6>
<p><img src="media/image13.png" alt=""></p>
<h3 id="blocksid">BlockSid</h3>
<p>Even if an OPAL device supports locking, an end user may choose to not
lock it. In this case, a malicious entity may set a password to lock the
OPAL device later and freeze the disk. In order to mitigate this attack,
we need block Secure Identifier (SID), even if we don&apos;t want to use it.</p>
<p>BlockSid is a policy. It can be controlled by the end user via TCG
Physical Presence (PP) interface, which we have discussed before.</p>
<p>In the normal boot path, at EndOfDxe event
<strong>OpalEndOfDxeEventNotify</strong>(),
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalDriver.c" target="_blank">OpalDriver.c</a>
<strong>SendBlockSidCommand</strong>() checks
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Library/Tcg2PhysicalPresenceLib.h" target="_blank">TCG2_BIOS_STORAGE_MANAGEMENT_FLAG_ENABLE_BLOCK_SID</a>
from the
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Include/Guid/Tcg2PhysicalPresenceData.h" target="_blank">Tcg2PhysicalPresenceFlags</a>
and sends an <strong>OpalBlockSid</strong>() command if it is set.</p>
<p>In the S3 resume path,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/Opal/OpalPassword/OpalPasswordPei.c" target="_blank">OpalPasswordPei.c</a>
<strong>UnlockOpalPassword</strong>() checks the same flag and sends an
<strong>OpalBlockSid</strong>() command after it unlocks the devices one by one.</p>
<p>See Figure 10 and Figure 13 for the BlockSid action in PP and OPAL
driver.</p>
<h3 id="tper-reset">TPer reset</h3>
<p>When a platform firmware detects the MOR request, it means an unexpected
system reset happened and the system might not erase the secrets from
the memory. It also means the disk protected region might be also
unlocked. In order to mitigate the reset attack, the platform not only
cleans the memory content, but the platform also needs to issue a TPer
reset command to the TCG storage devices.</p>
<p>The
<a href="https://github.com/tianocore/edk2/tree/master/SecurityPkg/Tcg/MemoryOverwriteControl" target="_blank">MemoryOverwriteControl</a>
module manages the
<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Include/Guid/MemoryOverwriteControl.h" target="_blank">MemoryOverwriteRequestControl</a>
(MOR) variable. At the EndOfDxe event,
<a href="https://github.com/tianocore/edk2/blob/master/SecurityPkg/Tcg/MemoryOverwriteControl/TcgMor.c" target="_blank">TcgMor.c</a>
<strong>TPerResetAtEndOfDxe</strong>() locates all security storage devices and sends
a TPer reset command in <strong>InitiateTPerReset</strong>().</p>
<p>The platform also needs to ensure all trusted storages are connected
before the EndOfDxe event. A PlatformBds module, such as
<a href="https://github.com/tianocore/edk2-platforms/blob/master/Platform/Intel/BoardModulePkg/Library/BoardBdsHookLib/BoardBdsHookLib.c" target="_blank">BoardBdsHookLib</a>,
needs to process the TCG MOR request. <strong>ProcessTcgMor</strong>() needs to check
if there is any MOR request and connect the platform specific trusted
storage.</p>
<p>See Figure 12 for the TPer reset action in MOR driver.</p>

                                
                                </section>
                            
                        </div>
                    </div>
                    
                    

<div>
    <hr>
    
      <h2>
        <div style="position:absolute;text-align:left">Understanding the Trusted Boot Chain Implementation</div>
        <div style="position:absolute;width:100%;text-align:center">DRAFT [03/30/2021 03:24:01]</div>
        <div style="text-align:right">Revision 1.0</div>
      </h2>  
    
</div>



                
            </div>

            
                
                <a href="2_Overview.html" class="navigation navigation-prev " aria-label="Previous page: Overview">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="4_Other_Trusted_Boot_Chains.html" class="navigation navigation-next " aria-label="Next page: Other Trusted Boot Chains">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"TCG Trusted Boot Chain in EDK II","level":"1.6","depth":1,"next":{"title":"Other Trusted Boot Chains","level":"1.7","depth":1,"path":"4_Other_Trusted_Boot_Chains.md","ref":"4_Other_Trusted_Boot_Chains.md","articles":[]},"previous":{"title":"Overview","level":"1.5","depth":1,"path":"2_Overview.md","ref":"2_Overview.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{"draft":"yes","title":"Understanding the Trusted Boot Chain Implementation","version":"Revision 1.0"},"plugins":["puml-aleung"],"pluginsConfig":{"puml-aleung":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"3_TCG_Trusted_Boot_Chain_in_EDKII.md","mtime":"2021-03-30T15:23:31.341Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2021-03-30T15:24:01.310Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

